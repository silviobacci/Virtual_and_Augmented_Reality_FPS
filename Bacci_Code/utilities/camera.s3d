#define MAX_VERT_ROT 		250
#define OFFEST_WIDTH		0 //9
#define OFFEST_HEIGHT		0 //31

#define FIRST_PERSON_VIEW	0
#define THIRD_PERSON_VIEW	1
#define FREE_CAMERA_VIEW	2
#define N_VIEWS				3

var CamPos = [0.0, 30, 30.0];
var CamDir; 

var current_view = FIRST_PERSON_VIEW;
var last_mouse_x = 0.0; 
var last_mouse_y = 0.0;
var last_mouse_z = 0.0;
var last_deltax = 0;
var counter = 0;
var meshRot_x = 0.0;
var meshRot_y = 0.0;
var offset_w = 8;
var offset_h = 30;
var meshRot_y_cumulative = 0.0;
var meshRot_x_cumulative = 0.0;
var rho = 1.2;

function init_camera() {
	CameraGetCurrent().SetPosition(my_players.array_player[0].position);
	CameraGetCurrent().SetRotation (0, 1, 1, 1);
	CameraGetCurrent().RotateGlobal(180 + my_players.array_player[0].angle_direction, 0, 1, 0);
}

function CameraMoveMouse() {	
	var	rot_sensitivity = 0.1;			
 	var deltax = Mouse.X;
	var deltay = Mouse.Y;
	
 	SetCursorPos(0.5, 0.5);

	if(deltax != 0)
		deltax = Floor(deltax - (window_w/2) + OFFEST_WIDTH);
	if(deltay != 0)
		deltay = Ceil(deltay - (window_h/2) + OFFEST_HEIGHT);

	meshRot_x_cumulative+= deltax;
	meshRot_y_cumulative+= deltay;

	if(abs(meshRot_y_cumulative) >  MAX_VERT_ROT){
		meshRot_y_cumulative-= deltay;
		deltay -= deltay * rot_sensitivity;
		deltay = 0;
	}

	CameraGetCurrent().RotateGlobal(deltax * rot_sensitivity, 0, 1, 0);
	CameraGetCurrent().RotateLocal (deltay * rot_sensitivity, 1, 0, 0);
	my_players.array_player[0].angle_direction = (my_players.array_player[0].angle_direction + deltax * rot_sensitivity) % 360;
	if(my_players.array_player[0].angle_direction < 0)
		my_players.array_player[0].angle_direction = 360 + my_players.array_player[0].angle_direction;
	//my_players.array_player[0].moving_direction = [new_direction.x, 0, new_direction.z];
}

function compute_theta(coord) {
	var x = coord.x;
	var y = coord.y;
	var z = coord.z;
	var theta = PI/2 - acos(y / ((x^2 + y^2 + z^2)^(1/2)));
	//var theta = PI/2 - atan2pi((x^2 + y^2 + z^2)^(1/2), y);	
	return theta;
}

function compute_phi(coord) {
	var x = coord.x;
	var z = coord.z;
	var ratio = x / z;
	//var phi = atan(z / x);
	var phi = atan2(x, z);
	return phi;
}

function ComputeView(backside_offset){
	//var theta = compute_theta(my_players.array_player[0].moving_direction);
	//var phi = compute_phi(my_players.array_player[0].moving_direction);
	var theta = 0;
	var phi = my_players.array_player[0].angle_direction * GRAD_TO_RAD;
	
	//var phit = phi * RAD_TO_GRAD;
	var thetat = theta * RAD_TO_GRAD;
	var phit = my_players.array_player[0].angle_direction;

	var cam_offset = rho * [sin(theta)*sin(phi), cos(theta), -sin(theta)*cos(phi)];

	my_players.array_player[0].obj_player.setRotation(-phit, 0, 1, 0);
	//my_players.array_player[0].obj_player.rotate(-thetat, 1, 0, 0);
	//trace(cam_offset);
	//trace(backside_offset);

	CameraGetCurrent().setPosition(my_players.array_player[0].position + cam_offset + backside_offset);
	var camera_pos = CameraGetCurrent().GetPosition();
	//trace(camera_pos);
	var position = my_players.array_player[0].position;
	//trace(position);
}

function FirstPersonView() {
	var backside_offset = [0,0,0];
	ComputeView(backside_offset);
	CameraMoveMouse();
}

function ThirdPerdonView() {
	var backside_offset = [-1, 0.2, -1];
	ComputeView(backside_offset);
	CameraMoveMouse();
}

function FreeCameraView() {
	CameraGetCurrent().setPosition([30.0, WORLD_SUN_HEIGHT, 30.0]);
	CameraSetTarget(my_players.array_player[0].position);
	CameraGetCurrent().Free();
	CameraMoveMouse_MBL_LC();
}

function update_camera() {
	if(my_keyboard.is_pressed(VK_LCONTROL)){
		current_view = (current_view + 1) % N_VIEWS;
		init_camera();
		meshRot_y_cumulative = 0.0;
		meshRot_x_cumulative = 0.0;
    }
    
    switch(current_view) {
    	case FIRST_PERSON_VIEW:
    		FirstPersonView();
    		break;
    	case THIRD_PERSON_VIEW:
    		ThirdPerdonView();
    		break;
    	case FREE_CAMERA_VIEW:
    		FreeCameraView();
    		break;
    }
}
