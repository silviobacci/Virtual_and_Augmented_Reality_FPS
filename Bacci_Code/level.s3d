#include "player.s3d"

#define FLOOR_TILING 5
#define WALL_HEIGHT 3

class level{
	var mesh_floor;
	var material_floor;
	var texture_floor;
	var matrix_level;
	var mesh_wall;
	var material_wall;
	var texture_wall;
	var array_wall;
	var array_player;
	var mymap;
	
	init();
	draw();
	addplayer(id, color, p);
	update();
	
	get_player_position();
};

function level::update(){
	foreach (var pl in array_player)
		pl.update(matrix_level);
}

function level::addplayer(id, color, p){
	var pl = player();
	pl.init(id, color, p);
	aadd(array_player, pl);
}

function level::init(){
	array_player = array(0);
	// Floor creation
	mesh_floor = CVmNewMesh(VRP_BOX);
	mesh_floor.scale(32,1,32);
	mesh_floor.translate(0, -1, 0);
	
	material_floor = CVmMaterial();
	material_floor.diffuse = [0, 1, 0, 1]; // R G B and alpha
	material_floor.ChangeTextureParams(VR_U_TILING, FLOOR_TILING);
	material_floor.ChangeTextureParams(VR_V_TILING, FLOOR_TILING);
	
	texture_floor = CVmTexture("marmo.png");
	
	material_floor.SetTexture(texture_floor);
	mesh_floor.ForceMaterial(material_floor);
	
	// Wall creation
	mesh_wall = CVmNewMesh(VRP_BOX);
	mesh_wall.scale(1,WALL_HEIGHT,1);
	
	material_wall = CVmMaterial();
	material_wall.diffuse = [1, 1, 1, 1]; // Blending with white means mulitply by 1, so the texture is unchamged
	material_wall.ChangeTextureParams(VR_V_TILING, WALL_HEIGHT);
	
	texture_wall = CVmTexture("mattoni04.png");
	
	material_wall.SetTexture(texture_wall);
	mesh_wall.ForceMaterial(material_wall);
	
	// Level creation
	var array_rows = LoadFile("level.txt");
	var array_rows_length = len(array_rows);
	var array_columns_length = len(array_rows[0]);
	array_wall = array(0);
	
	matrix_level = array(array_rows_length - 1);
	
	for (var i = 0; i < array_rows_length - 1; i++){
		matrix_level[i] = array(array_columns_length);

		for (var j = 0; j < array_columns_length; j++){
			var tmp = array_rows[i][j];
			if(tmp == "1"){
				matrix_level[i][j] = 1;
				var tmp_obj = CVmObj(mesh_wall);
				tmp_obj.SetPosition(j, 0, i);
				
				// The elemnts should be eliomited by the gurbage collector, but it is linked to a global variable
				// so if the global variable survies also the references survive
				aadd(array_wall, tmp_obj);	
			}
			else
				matrix_level[i][j] = 0;
		}
	}
}

function level::get_player_position() {
	var n_players = len(array_player);
	var positions = array(n_players);
	var i = 0;
	foreach (var pl in array_player) {
		positions[i] = pl.get_position();
		i++;
	}
	
	return positions;
}

function level::draw(){
	mesh_floor.draw();
	// mesh_wall.draw();
	
//	var l = len(array_wall);
//	for (var i = 0; i < l - 1; i++){
//		array_wall[i].draw();
//	}
	
	foreach (var aw in array_wall)
		aw.draw();
		
	var n_players = len(array_player);
	var positions = array(n_players);
	var i = 0;
	foreach (var pl in array_player) {
		positions[i] = pl.get_position();
		var boh  = positions[i];
		i++;
		pl.draw();	
	}
}