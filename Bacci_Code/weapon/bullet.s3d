#define RAILGUN_N_BULLETS 		25
#define RAILGUN_AMMUNITIONS		20
#define RAILGUN_NAME			"railgun"
#define RAILGUN_MESH			"railgun.aam"
#define RAILGUN_BULLET_MASS		0.008
#define RAILGUN_BULLET_RADIUS 	0.003
#define RAILGUN_SHOOT_FORCE 	500

#define ROCKETL_N_BULLETS 		25
#define ROCKETL_AMMUNITIONS		20
#define ROCKETL_NAME			"rocketl"
#define ROCKETL_MESH			"rocketl.aam"
#define ROCKETL_BULLET_MASS		0.008
#define ROCKETL_BULLET_RADIUS 	0.003
#define ROCKETL_SHOOT_FORCE 	500

#define g 						9.81
#define n				 		0.0000186

class bullet{
	var mesh_bullet;
	var obj_bullet;
	
	var angle;
	var position;
	var old_position;
	var dir;

	var is_flying;
	var elapsed_time;
	var delta_t;
	
	var mass;
	var radius;
	var viscous;
	
	var dx;
	var dy;
	var speedx;
	var speedy; 
	var accx;
	var accy;
	
	var obj;
	var mesh;

	create_bullet();
	init(br, bm);
	
	check_if_hit(coord);
	check_collision(matrix_level);
	update_dynamics();
	update(matrix_level);
	
	draw();
	
	shoot(p, d, sf);
};

function bullet::create_bullet() {
	mesh_bullet = CVmnewMesh(VRP_SPHERE);
	mesh_bullet.scale(0.1);
	mesh_bullet.ModulateMaterials([0, 0, 0]);
	obj_bullet = CVmObj(mesh_bullet);
}

function bullet::init(br, bm){
	obj = array(0);
	mesh = CVmNewMesh(VRP_BOX);
	mesh.scale(2);
	
	radius = br;
	mass = bm;
	viscous = 6* PI* n * radius / mass;
	
	delta_t = TIME_STEP_UPDATE;
	
	is_flying = false;
	elapsed_time = 0.0;
	
	create_bullet();
}

function bullet::update_dynamics(){
	speedx	+= accx * delta_t;
	speedy	+= accy * delta_t;

	dx = delta_t * speedx;
	dy = delta_t * speedy;
	
	angle = atan(dy/dx);
	
	var tmp = angle * RAD_TO_GRAD;
	//trace(tmp);
		 
	position[0] += dir[0] * dx;
	position[1] += dy;
	position[2] += dir[2] * dx;
	
	accx = - viscous / mass * sqrt(speedx^2 + speedy^2) * cos(angle);
	accy = - viscous / mass * sqrt(speedx^2 + speedy^2) * sin(angle) - g;
}

function bullet::update(matrix_level){
	if(is_flying){
		old_position = position;
		update_dynamics();
		
		if(check_collision(matrix_level) || position[1] <= 0)
			is_flying = false; 
		else
			obj_bullet.setposition(position);
	}
}

function bullet::shoot(p, d, sf){
	dx = 0.0; 
	dy = 0.0;
	speedx = 0.0;
	speedy = 0.0;
	angle = d[1];
	//angle = 0;
	var tmp = angle * RAD_TO_GRAD;
	//trace(tmp);
	accx =  sf / mass * cos(angle);
	accy =  sf / mass * sin(angle) - g;
	
	//position = p + [-0.2, 1, 0];
	position = p + [0, 1.2, 0];
	//position = CameraGetCurrent().GetPosition();
	dir = d; 
	is_flying = true;
}

function bullet::draw(){
	if(is_flying == true)
		obj_bullet.draw();
	foreach(var o in obj)
		o.draw();
}