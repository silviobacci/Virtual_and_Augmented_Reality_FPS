#define RAILGUN_N_BULLETS 		25
#define RAILGUN_AMMUNITIONS		20
#define RAILGUN_NAME			"railgun"
#define RAILGUN_MESH			"railgun.aam"
#define RAILGUN_BULLET_MASS		0.008
#define RAILGUN_BULLET_RADIUS 	0.003
#define RAILGUN_SHOOT_FORCE 	500

#define ROCKETL_N_BULLETS 		25
#define ROCKETL_AMMUNITIONS		20
#define ROCKETL_NAME			"rocketl"
#define ROCKETL_MESH			"rocketl.aam"
#define ROCKETL_BULLET_MASS		0.008
#define ROCKETL_BULLET_RADIUS 	0.003
#define ROCKETL_SHOOT_FORCE 	500

#define GUN_POSITION_X			0
#define GUN_POSITION_Y			1
#define GUN_POSITION_Z			0.2

#define g 						9.81
#define n				 		0.0000186

class bullet{
	var mesh_bullet;
	var obj_bullet;
	
	var angle_x;
	var angle_y;
	var position;
	var old_position;
	var dir;

	var is_flying;
	var elapsed_time;
	var delta_t;
	
	var mass;
	var radius;
	var viscous;
	
	var dx;
	var dy;
	var speedx;
	var speedy; 
	var accx;
	var accy;
	
	var obj;
	var mesh;

	create_bullet();
	init(br, bm);
	
	check_if_hit(coord);
	check_collision();
	update_dynamics();
	update();
	
	draw();
	
	shoot(p, a, d, sf);
};

function bullet::create_bullet() {
	mesh_bullet = CVmnewMesh(VRP_SPHERE);
	mesh_bullet.scale(0.1);
	mesh_bullet.ModulateMaterials([0, 0, 0]);
	obj_bullet = CVmObj(mesh_bullet);
}

function bullet::init(br, bm){
	obj = array(0);
	mesh = CVmNewMesh(VRP_BOX);
	mesh.scale(2);
	
	radius = br;
	mass = bm;
	viscous = 6* PI* n * radius / mass;
	
	delta_t = TIME_STEP_UPDATE;
	
	is_flying = false;
	elapsed_time = 0.0;
	
	create_bullet();
}

function bullet::update_dynamics(){
	speedx += accx * delta_t;
	speedy += accy * delta_t;
	var speed = sqrt(speedx^2 + speedy^2);

	dx = delta_t * speedx;
	dy = delta_t * speedy;
	
	angle_y = atan(dy/dx);
	
	position.x += dx * cos(angle_x);
	position.y += dy;
	position.z += dx * sin(angle_x);
	
	accx = - viscous * speed * cos(angle_y) / mass;
	accy = - viscous * speed * sin(angle_y) / mass - g;
}

function bullet::update(){
	if(is_flying){
		old_position = position;
		update_dynamics();
		
		if(check_collision() || position[1] <= 0)
			is_flying = false; 
		else
			obj_bullet.setposition(position);
	}
}

function bullet::shoot(p, a, d, sf){
	var gun_position = [GUN_POSITION_X, GUN_POSITION_Y, -GUN_POSITION_Z];
	gun_position = VectorRotate(a, 0, 1, 0, gun_position);
	dx = 0.0;
	dy = 0.0;
	speedx = 0.0;
	speedy = 0.0;
	angle_x = atan2pi(d.z, d.x);
	angle_y = asin(d.y);
	//angle_y += atan(cos(angle_y) / (sin(angle_y) + 1 / (CameraGetCurrent().GetPosition().y - GUN_POSITION_Y)));
	//angle_x += atan(cos(angle_y) / GUN_POSITION_Z);
	accx = sf * cos(angle_y) / mass;
	accy = sf * sin(angle_y) / mass - g;
	
	//position = p + gun_position;
	position = CameraGetCurrent().GetPosition();
	dir = d;
	is_flying = true;
}

function bullet::draw(){
	if(is_flying == true)
		obj_bullet.draw();
	foreach(var o in obj)
		o.draw();
}