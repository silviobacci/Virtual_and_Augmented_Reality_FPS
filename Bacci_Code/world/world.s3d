#define WORLD_FLOOR_TILING 		30
#define WORLD_WALL_HEIGHT 		1
#define WORLD_LADDER_HEIGHT		0.2
#define WORLD_SKY_HEIGHT	 	0
#define WORLD_SUN_HEIGHT	 	45

#define	N_STEPS					WORLD_DEFAULT_DIM / WORLD_LADDER_HEIGHT

#define UP						1
#define DOWN					2
#define R						3
#define L						4

#define	WORLD_MAP_FILENAME		"level.txt"

#define	WORLD_DEFAULT_DIM		1

#define	WORLD_SUN_POSITION		[10.0, 20.0, 10.0]
#define	WORLD_SUN_DIFFUSE		[255, 255, 255] / 255.0

#define	WORLD_SKY_COLOR			[255, 255, 255] / 255.0
#define	WORLD_SKY_MESH			"sky.aam"

#define	WORLD_FLOOR_COLOR		[0, 255, 0] / 255.0
#define	WORLD_FLOOR_IMAGE		"grass.jpg"

#define	WORLD_WALL_COLOR		[255, 255, 255] / 255.0
#define	WORLD_WALL_IMAGE		"bricks.png"

// scala su: 		1 2 4 5 7 8
// scale giù: 		a b c d e f
// scala destra: 	g h i l m n
// scala sinistra: 	o p q r s t

var my_world;

class world{
	var mesh_sky;
	var material_sky;
	var texture_sky;
	
	var mesh_floor;
	var material_floor;
	var texture_floor;
	
	var mesh_wall;
	var material_wall;
	var texture_wall;
	
	var mesh_ladder;
	var material_ladder;
	var texture_ladder;
	
	var map;
	var matrix;
	var width;
	var height;
	
	var obj_array;
	var wall_array;
	var ladder_array;
	var wall;
	
	init();
	draw();
	
	find_wall_height(height);
	create_map();
	create_sun();
	create_sky();
	create_floor();
	create_ladder(height_scale, dir, i, j);
	create_wall(height_scale, i, j);
};

function world::find_wall_height(height) {
	switch(height) {
		case "1":
		case "a":
		case "g":
		case "o":
			return 1;
		case "2":
		case "b":
		case "h":
		case "p":
			return 2;
		case "4":
		case "c":
		case "i":
		case "q":
			return 3;
		case "5":
		case "d":
		case "l":
		case "r":
			return 4;
		case "7":
		case "e":
		case "m":
		case "s":
			return 5;
		case "8":
		case "f":
		case "n":
		case "t":
			return 6;
		default:
			return val(height);
	}	
}

function world::create_map() {
	var array_matrix = LoadFile(WORLD_MAP_FILENAME);
	height = len(array_matrix) - 1;
	width = len(array_matrix[0]);
	
	wall_array = array(0);
	obj_array = array(height * N_STEPS);
	matrix = array(height * N_STEPS);
	map = array(height);
	
	for (var i = 0; i < height; i++){
		map[i] = array(width);
		for(var k = 0; k < N_STEPS; k++) {
			matrix[i * N_STEPS + k] = array(width * N_STEPS);
			obj_array[i * N_STEPS + k] = array(width * N_STEPS);
		}

		for (var j = 0; j < width; j++){
			map[i][j] = find_wall_height(array_matrix[i][j]);
			
			if(map[i][j] > 0)	
				switch(array_matrix[i][j]) {
					case "1":
					case "2":
					case "4":
					case "5":
					case "7":
					case "8":
						map[i][j] = map[i][j] - 1;
						create_ladder(map[i][j], UP, i, j);
						for(var k = 0; k < N_STEPS; k++)
							for(var v = 0; v < N_STEPS; v++) {
								matrix[i * N_STEPS + k][j * N_STEPS + v] = find_wall_height(array_matrix[i+1][j]) + (N_STEPS - 1 - k) / ToFloat(N_STEPS - 1) * map[i][j];
								obj_array[i * N_STEPS + k][j * N_STEPS + v] = ladder_array[k];	
							}
						break;
					case "a":
					case "b":
					case "c":
					case "d":
					case "e":
					case "f":
						map[i][j] = map[i][j] - 1;
						create_ladder(map[i][j], DOWN, i, j);
						for(var k = 0; k < N_STEPS; k++)
							for(var v = 0; v < N_STEPS; v++) {
								matrix[i * N_STEPS + k][j * N_STEPS + v] = find_wall_height(array_matrix[i-1][j]) + k / ToFloat(N_STEPS - 1) * map[i][j];
								obj_array[i * N_STEPS + k][j * N_STEPS + v] = ladder_array[N_STEPS - 1 - k];	
							}
						break;
					case "g":
					case "h":
					case "i":
					case "l":
					case "m":
					case "n":
						map[i][j] = map[i][j] - 1;
						create_ladder(map[i][j], R, i, j);
						for(var k = 0; k < N_STEPS; k++)
							for(var v = 0; v < N_STEPS; v++) {
								matrix[i * N_STEPS + k][j * N_STEPS + v] = find_wall_height(array_matrix[i][j+1]) + (N_STEPS - 1 - v) / ToFloat(N_STEPS - 1) * map[i][j];
								obj_array[i * N_STEPS + k][j * N_STEPS + v] = ladder_array[N_STEPS - 1 - v];	
							}
						break;
					case "o":
					case "p":
					case "q":
					case "r":
					case "s":
					case "t":
						map[i][j] = map[i][j] - 1;
						create_ladder(map[i][j], L, i, j);
						for(var k = 0; k < N_STEPS; k++)
							for(var v = 0; v < N_STEPS; v++) {
								matrix[i * N_STEPS + k][j * N_STEPS + v] = find_wall_height(array_matrix[i][j-1]) + v / ToFloat(N_STEPS - 1) * map[i][j];
								obj_array[i * N_STEPS + k][j * N_STEPS + v] = ladder_array[v];	
							}
						break;
					case "3":
					case "6":
					case "9":
						map[i][j] = map[i][j] * 2 / 3;
						create_wall(map[i][j], i, j);
						for(var k = 0; k < N_STEPS; k++)
							for(var v = 0; v < N_STEPS; v++) {
								matrix[i * N_STEPS + k][j * N_STEPS + v] = map[i][j];
								obj_array[i * N_STEPS + k][j * N_STEPS + v] = wall;		
						}
						break;
				}
			else
				for(var k = 0; k < N_STEPS; k++)
					for(var v = 0; v < N_STEPS; v++) 
						matrix[i * N_STEPS + k][j * N_STEPS + v] = map[i][j];
		}
	}
}

function world::create_sun() {
	var sun = CVmLight();
	sun.SetPosition([width / 2.0, WORLD_SUN_HEIGHT, height / 2.0]);
	sun.SetDiffuse(1, 1, 1);
	sun.Enable();
}

function world::create_sky() {
	mesh_sky = CVmNewMesh(WORLD_SKY_MESH);
	mesh_sky.translate(width / 2.0, WORLD_SKY_HEIGHT, height / 2.0);
}

function world::create_floor() {
	mesh_floor = CVmNewMesh(VRP_BOX);
	mesh_floor.scale(width, WORLD_DEFAULT_DIM, height);
	mesh_floor.translate(0, -WORLD_DEFAULT_DIM, 0);
	
	material_floor = CVmMaterial();
	material_floor.diffuse = WORLD_FLOOR_COLOR;
	material_floor.ChangeTextureParams(VR_U_TILING, WORLD_FLOOR_TILING);
	material_floor.ChangeTextureParams(VR_V_TILING, WORLD_FLOOR_TILING);
	
	texture_floor = CVmTexture(WORLD_FLOOR_IMAGE);
	
	material_floor.SetTexture(texture_floor);
	mesh_floor.ForceMaterial(material_floor);
}

function world::create_ladder(height_scale, dir, i, j) {
	var ladder;
	ladder_array = array(0);
	material_ladder = CVmMaterial();
	material_ladder.diffuse = WORLD_WALL_COLOR; 
	material_ladder.ChangeTextureParams(VR_V_TILING, WORLD_WALL_HEIGHT * height_scale + WORLD_LADDER_HEIGHT);
	
	texture_ladder = CVmTexture(WORLD_WALL_IMAGE);
	
	material_ladder.SetTexture(texture_ladder);
	
	mesh_ladder = array(WORLD_DEFAULT_DIM / WORLD_LADDER_HEIGHT);
	
	for (var k = 0; k < WORLD_DEFAULT_DIM / WORLD_LADDER_HEIGHT; k++) {
		mesh_ladder[k] = CVmNewMesh(VRP_BOX);
		mesh_ladder[k].scale(WORLD_DEFAULT_DIM, WORLD_WALL_HEIGHT * height_scale + WORLD_LADDER_HEIGHT, WORLD_DEFAULT_DIM - k * WORLD_LADDER_HEIGHT);
		mesh_ladder[k].ForceMaterial(material_ladder);
		
		switch(dir) {
			case UP:
				ladder = CVmObj(mesh_ladder[k]);
				ladder.SetPosition(j, k * WORLD_LADDER_HEIGHT, i);
				break;
			case DOWN:
				mesh_ladder[k].Rotate(180, 0, 1, 0);
				ladder = CVmObj(mesh_ladder[k]);
				ladder.SetPosition(j + 1, k * WORLD_LADDER_HEIGHT, i + 1);
				break;
			case R:
				mesh_ladder[k].Rotate(90, 0, 1, 0);
				ladder = CVmObj(mesh_ladder[k]);
				ladder.SetPosition(j, k * WORLD_LADDER_HEIGHT, i + 1);
				break;
			case L:
				mesh_ladder[k].Rotate(270, 0, 1, 0);
				ladder = CVmObj(mesh_ladder[k]);
				ladder.SetPosition(j + 1, k * WORLD_LADDER_HEIGHT, i);
				break;
		}
						
		aadd(ladder_array, ladder);	
		aadd(wall_array, ladder);
	}
}

function world::create_wall(height_scale, i, j) {
	mesh_wall = CVmNewMesh(VRP_BOX);
	mesh_wall.scale(WORLD_DEFAULT_DIM, WORLD_WALL_HEIGHT * height_scale, WORLD_DEFAULT_DIM);
	
	material_wall = CVmMaterial();
	material_wall.diffuse = WORLD_WALL_COLOR; 
	material_wall.ChangeTextureParams(VR_V_TILING, WORLD_WALL_HEIGHT * height_scale);
	
	texture_wall = CVmTexture(WORLD_WALL_IMAGE);
	
	material_wall.SetTexture(texture_wall);
	mesh_wall.ForceMaterial(material_wall);
	
	wall = CVmObj(mesh_wall);
	wall.SetPosition(j, 0, i);
	
	aadd(wall_array, wall);
}

function world::init(){
	create_map();
	create_sun();
	create_sky();
	create_floor();
}

function world::draw(){
	mesh_sky.draw();
	mesh_floor.draw();
	
	foreach(var wall in wall_array)
		wall.draw();
}