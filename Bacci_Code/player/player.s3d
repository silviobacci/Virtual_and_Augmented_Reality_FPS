#define PLAYER_SPEED 		0.07
#define PLAYER_SPEED_STEP 	0.001
#define PLAYER_ANGLE_STEP 	0.01
#define SWAT_START_WALK 	16
#define SWAT_END_WALK 		48
#define SWAT_TOTAL_FRAMES 	32
#define SWAT_FRAME_STEP 	0.35
#define CLIP_SIZE 			500

#define PLAYER_RADIUS		30
#define PLAYER_MASS			80
#define VISCOUS_PLAYER 		6* PI* n * PLAYER_RADIUS  / PLAYER_MASS
#define JUMP_FORCE 			15000
#define JUMP_ANGLE 			0

class player{
	//Player-related 
	var mesh_player_lower;
	var mesh_player_upper;
	
	var obj_player_lower;
	var obj_player_upper;
	var obj_player;
	
	var position;
	var angle_direction;
	var moving_direction;
	var current_frame; 
	var id;
	var speed;
	
	//jump related 
	var is_jumping;
	var dx;
	var dy;
	var accx;
	var accy;
	var speedx;
	var speedy; 
	var angle;
	var delta_t;
	
	//Player-associated
	var my_railgun; 
	var my_rocketl; 
	var current_weapon;
	
	init(i, p);
	create_player();
	
	get_position();
	
	change_weapon(new_weapon);
	shoot();
	reset_jump_dynamics();
	init_jump_dynamic();
	update_jump_dynamics();
	update_speed_position();
	check_collision(matrix_level);
	update(matrix_level);
	
	draw();
};

function player::create_player(){
	mesh_player_lower = CVmNewMesh("swat_lower.aam");
	var sf1 = mesh_player_lower.Normalize(1);
	
	mesh_player_upper = CVmNewMesh("swat_upper.aam"); 
	mesh_player_upper.scale(sf1);

	my_railgun.init(RAILGUN_N_BULLETS, RAILGUN_MESH, RAILGUN_BULLET_RADIUS, RAILGUN_BULLET_MASS, RAILGUN_SHOOT_FORCE, sf1);
	my_rocketl.init(ROCKETL_N_BULLETS, ROCKETL_MESH, ROCKETL_BULLET_RADIUS, ROCKETL_BULLET_MASS, ROCKETL_SHOOT_FORCE, sf1);
	
	obj_player_upper = CVmObj(mesh_player_upper);
	obj_player_lower = CVmObj(mesh_player_lower);
	obj_player = CVmObj();
	
	obj_player.AddChild(obj_player_lower);
	obj_player.AddChild(obj_player_upper);
	obj_player_upper.AddChild(current_weapon.obj_gun);
	obj_player_upper.setPivotPoint(0,0,0);
	obj_player.setposition(position);
}

function player::init(i, p){
	id = 				i;
	position = 			p;
	current_frame = 	0;
	speed = 			0.0;
	angle_direction = 	0.0;
	is_jumping = 		false;
	delta_t = 			1.0 / FRAME_RATE;
	moving_direction = 	[sin(angle_direction), 0 , cos(angle_direction)]; 
	my_railgun = 		weapon();
	my_rocketl = 		weapon();
	current_weapon =	my_rocketl;
	
    create_player();
    change_weapon(my_rocketl);
}

function player::get_position(){
	return obj_player.GetPosition();
}

function player::reset_jump_dynamics(){
	dx = 			0.0;
	dy = 			0.0;
	speedx = 		0.0;
	speedy = 		0.0;
	accx =			0.0;
	accy = 			0.0;
	is_jumping = 	false;
}

function player::init_jump_dynamic(){
	reset_jump_dynamics();
	speedx = speed;

	if(speed > 0)
		angle = GRAD_TO_RAD * 45;
	else
		angle = GRAD_TO_RAD * 90;
		
	accx = JUMP_FORCE / PLAYER_MASS * cos(angle);
	accy = JUMP_FORCE / PLAYER_MASS * sin(angle) - g;
	is_jumping = true;
}

function player::update_jump_dynamics(){
	speedx += accx * delta_t; 
	speedy += accy * delta_t;
		
	dx = delta_t * speedx;
	dy = delta_t * speedy;
		
	angle = atan(dy/dx);
	
	position[0] += moving_direction[0] * dx;
	position[1] += dy;
	position[2] += moving_direction[2] * dx;
	
	if(position[1] <= 0){
		position[1] = 0;
		reset_jump_dynamics();
	}
	
	accx = - VISCOUS_PLAYER / PLAYER_MASS * sqrt(speedx^2 + speedy^2) * cos(angle);
	accy = - VISCOUS_PLAYER / PLAYER_MASS * sqrt(speedx^2 + speedy^2) * sin(angle) - g;
}

function player::change_weapon(new_weapon){
	if(current_weapon != null)
		obj_player_upper.RemoveChild(current_weapon.obj_gun);
	current_weapon = new_weapon;
	obj_player_upper.AddChild(current_weapon.obj_gun);
}

function player::shoot(){
	current_weapon.shoot(position, moving_direction);
}

function player::check_collision(matrix_level){
	var bb1 = mesh_player_upper.GetBoundingBox();
	var bb2 = mesh_player_lower.GetBoundingBox();
	
	var c = array(8);
	
	c[0] = position + [bb1[0], 	0, 	bb2[5]];
	c[1] = position + [0,     	0, 	bb2[5]];
	c[2] = position + [bb1[3],	0, 	bb2[5]];
	c[3] = position + [bb1[3],	0, 	0];
	c[4] = position + [bb1[3],	0, 	bb2[2]];
	c[5] = position + [0,		0, 	bb2[2]];
	c[6] = position + [bb1[0],	0, 	bb2[2]];
	c[7] = position + [bb1[0],	0, 	0];
	
	for (var i = 0; i < 8; i++){
		var ix = int(c[i].x);
		var iz = int(c[i].z);
		if(matrix_level[iz][ix] == 1) 
			return true;
	}

	// obj_player.SetPosition(position);
	// obj_player.SetRotation(RAD_TO_GRAD * angleY, [0, 1, 0]);
	return false;
}

function player::update_speed_position(){
	if(my_keyboard.is_pressed(VK_W)){
		if(speed < PLAYER_SPEED)
			speed += PLAYER_SPEED_STEP;
	}
	else if(my_keyboard.is_pressed(VK_S)){
		if(speed > -PLAYER_SPEED/2)
			speed -= 2*PLAYER_SPEED_STEP;
	}
	else if(speed > 0)
		speed -= PLAYER_SPEED_STEP;
	else if(speed < 0)
		speed += PLAYER_SPEED_STEP;
		
	if(abs(speed) < 0.001) {
		speed = 0;
		return;
	}
		
	if(speed > 0)
		current_frame = (current_frame + SWAT_FRAME_STEP *(0.95 + speed))% SWAT_TOTAL_FRAMES;
	else if((current_frame = (current_frame - SWAT_FRAME_STEP *(0.95 + speed))% SWAT_TOTAL_FRAMES) <= 0)
		current_frame += SWAT_TOTAL_FRAMES;

	position += speed * moving_direction;
}

function player::update(matrix_level) {
	var old_position = position;

	if(my_keyboard.is_pressed(VK_SHIFT))
		shoot();
	else if(my_keyboard.is_pressed(VK_A)){					
		var dir_ortho = [moving_direction[2], 0, -moving_direction[0]];
		position += PLAYER_SPEED * dir_ortho;	
	}
	else if(my_keyboard.is_pressed(VK_D)){
		var dir_ortho = [-moving_direction[2], 0, moving_direction[0]];
		position += PLAYER_SPEED * dir_ortho;	
	}
	else if(my_keyboard.is_pressed(VK_C)){
		if(current_weapon == my_railgun)
			change_weapon(my_rocketl);	
		else
			change_weapon(my_railgun);
	}
	
	if(my_keyboard.is_pressed(VK_SPACE) && !is_jumping)
		init_jump_dynamic();
	
	if(is_jumping)
		update_jump_dynamics();
	else
		update_speed_position();
		
	if(check_collision(matrix_level)){
		position = old_position;
		speed = 0;
	}

	obj_player.setposition(position);
	
	current_weapon.update();
	
	//obj_player.setRotation(RAD_TO_GRAD * angle_direction, [0,1,0]);
}

function player::draw(){											
	obj_player.draw(VR_FRAMENUMBER, SWAT_START_WALK + current_frame);
	current_weapon.draw();
}